# be-chess
소프티어 부트캠프 2기 체스 프로젝트

---

## step 2 todo (or 기록 사항)
- white, black이 아닌 입력에 대한 예외처리, 추가적인 케이스 구현 필요
- 4번 요구 사항은 추가적인 작업이 필요하지 않았다. (Pawn.add() 메서드가 Pawn 객체만을 입력받기 때문에)
- 중복 찾아내는 어려움 + 메서드 분리 정도에 대한 고민 -> assert 메서드를 다시 wrapping할 필요가 있을 지? 가독성과 코드 길이의 trade off <br> -> 래핑한 메서드가 재사용되지 않을 것 같고, 충분히 가독성이 있다고 판단해서 분리하지 않음
-> BoardTest, PawnTest 리팩토링 필요 parameterized test, 다른 코드 참고해서. 

## step 3 기록 사항   

- 유지보수하기 좋은 코드란? 체스 애플리케이션에서 요구사항이 어떻게 바뀔 수 있는 지. 이 부분을 어떻게 cover할 수 있을 지 고민
- 위치에 대한 정보를 Pawn 객체에서 저장할 지, board에서 저장할 지에 대한 고민 -> 두 클래스의 의미, 본질을 생각했을 때 후자라고 생각
- 기물의 representation을 어떻게 구현할 것인가? -> 생성자에서 인자를 따로 받는 것은 비효율적이라고 판단했다. representation은 color에 종속되는 요소이기 때문에, 의미가 중복되고 정합성을 해칠 수 있을 것이라고 생각했다.
- 요구 사항이 단계별로 잘게 나뉘어져 있어서 이것에 의존하게 되는 것 같다. 기능 요구사항만 보고 어떤 형태로 코딩해야할 지 고민하는 과정을 먼저 가지는 식의 학습 방식도 좋을 것 같다는 생각이 들었다.
- Pawn의 생성자에서 입력값을 uppercase로 바꾸는 부분 역할 분리 필요할 지 고민 <br>
- BoardTest에서 initialize() 테스트하는 함수는, 초기화된 board list를 직접 비교하는 것이 엄밀한 것 아닌가?
- 입출력을 main()에서 모두 구현하는 게 맞을 지에 대한 고민
- enum으로 (color, representation)을 나타내기

## step 4 기록 사항
- private 생성자를 만들어 직접 객체 생성을 막는 방법의 장점 고민
- Piece의 representation이 더 이상 color에 종속되지 않는다. 어떻게 관리하는 것이 좋을 지.. 따로 enum으로 빼는 게 맞을 지...
- enum을 문자열로 변환해서 비교하는 게 아니라, 객체 자체를 이용하기

## step 5 기록 사항
- 행을 Rank로 변환하는 것의 장점?
- 필드를 enum으로 변환하는 데 발생하는 비용, 수정 사항들을 알게 되었다.
- representation을 type에 필드로 추가하는 것이 바람직한가
- enum을 Piece 내부 클래스로 선언함으로써 의미를 명확하게, 계층 구조를 깔끔하게 할 수 있다.
- 팩토리 메서드 패턴을 적용해서 내부를 더 잘 숨길 수 있게 되었다. 
- createWhite(), createBlack()은 인자 하나를 줄일 뿐이고, 메서드 간의 의존 관계만 더 복잡해지는 것 같다. 그냥 이 메서드들을 public으로 직접 사용하게 했을 때의 단점은? 내부가 덜 감춰지는 건가?
- Board 상의 빈 공간도 Piece 객체로 채워넣는 것의 장점은, 보드 2차원 배열 상의 원소들을 일관성 있게 관리할 수 있다는 점에서 발생한다고 생각한다.
  - null로 인해 발생하는 예외에서 자유로워진다.
  - Board의 빈 공간이라는 의미를 부여할 수 있다.
  - 출력과 기물 관리, 이동 등의 로직을 일반화할 수 있다. 예를 들어, 이전의 코드에서는 빈 공간을 출력하는 부분에서 null check 후 추가적인 상수 문자를 출력해야했다.
- Board의 행을 따로 wrap하는 것의 장점?
  - 행마다 발생하는 추가적인 기능을 구현하기에 편리해진다. Rank라는 의미를 부여할 수 있다. 명세에서 Rank 별로 처리해야하는 로직 등이 있다면 확실히 이와 같은 리팩토링이 필요할 것 같다. 
- 메서드 내의 지역 변수 이름을 어떻게 지으면 좋을까.. 일시적인 변수
- inline variable이 좋을 지, 변수를 선언해서 반환하는 게 좋을 지에 대해서 고민했다. 해당 부분이 얼마나 직관적으로 읽히는 지에 따라서 결정할 수 있을 것 같다.
- Position을 클래스로 분리하는 것의 장점
- move() 메서드명이 그 역할을 나타내지 않는 것 같다. 차후의 과제에서 수정될 것으로 보인다.
- Piece comparable 구현에 대한 고민 -> 명세에 따라 다르겠지만, Piece 객체 자체를 비교하는 기준이 score는 아닐 것이라고 판단해서, board의 메서드단에서 comparator를 구현했다.
- Rank에서 count()를 오버로딩하는 것이 바람직한가
