# be-chess
소프티어 부트캠프 2기 체스 프로젝트

---

## step 2 todo (or 기록 사항)
- white, black이 아닌 입력에 대한 예외처리, 추가적인 케이스 구현 필요
- 4번 요구 사항은 추가적인 작업이 필요하지 않았다. (Pawn.add() 메서드가 Pawn 객체만을 입력받기 때문에)
- 중복 찾아내는 어려움 + 메서드 분리 정도에 대한 고민 -> assert 메서드를 다시 wrapping할 필요가 있을 지? 가독성과 코드 길이의 trade off <br> -> 래핑한 메서드가 재사용되지 않을 것 같고, 충분히 가독성이 있다고 판단해서 분리하지 않음
-> BoardTest, PawnTest 리팩토링 필요 parameterized test, 다른 코드 참고해서. 

## step 3 기록 사항   

- 유지보수하기 좋은 코드란? 체스 애플리케이션에서 요구사항이 어떻게 바뀔 수 있는 지. 이 부분을 어떻게 cover할 수 있을 지 고민
- 위치에 대한 정보를 Pawn 객체에서 저장할 지, board에서 저장할 지에 대한 고민 -> 두 클래스의 의미, 본질을 생각했을 때 후자라고 생각
- 기물의 representation을 어떻게 구현할 것인가? -> 생성자에서 인자를 따로 받는 것은 비효율적이라고 판단했다. representation은 color에 종속되는 요소이기 때문에, 의미가 중복되고 정합성을 해칠 수 있을 것이라고 생각했다.
- 요구 사항이 단계별로 잘게 나뉘어져 있어서 이것에 의존하게 되는 것 같다. 기능 요구사항만 보고 어떤 형태로 코딩해야할 지 고민하는 과정을 먼저 가지는 식의 학습 방식도 좋을 것 같다는 생각이 들었다.
- Pawn의 생성자에서 입력값을 uppercase로 바꾸는 부분 역할 분리 필요할 지 고민 <br>
- BoardTest에서 initialize() 테스트하는 함수는, 초기화된 board list를 직접 비교하는 것이 엄밀한 것 아닌가?
- 입출력을 main()에서 모두 구현하는 게 맞을 지에 대한 고민
- enum으로 (color, representation)을 나타내기

## step 4 기록 사항
- private 생성자를 만들어 직접 객체 생성을 막는 방법의 장점 고민
- Piece의 representation이 더 이상 color에 종속되지 않는다. 어떻게 관리하는 것이 좋을 지.. 따로 enum으로 빼는 게 맞을 지...
- enum을 문자열로 변환해서 비교하는 게 아니라, 객체 자체를 이용하기

## step 5 기록 사항
- 행을 Rank로 변환하는 것의 장점?
- 필드를 enum으로 변환하는 데 발생하는 비용, 수정 사항들을 알게 되었다.
- representation을 type에 필드로 추가하는 것이 바람직한가
- enum을 Piece 내부 클래스로 선언함으로써 의미를 명확하게, 계층 구조를 깔끔하게 할 수 있다.
- 팩토리 메서드 패턴을 적용해서 내부를 더 잘 숨길 수 있게 되었다. 
- createWhite(), createBlack()은 인자 하나를 줄일 뿐이고, 메서드 간의 의존 관계만 더 복잡해지는 것 같다. 그냥 이 메서드들을 public으로 직접 사용하게 했을 때의 단점은? 내부가 덜 감춰지는 건가?
- Board 상의 빈 공간도 Piece 객체로 채워넣는 것의 장점은, 보드 2차원 배열 상의 원소들을 일관성 있게 관리할 수 있다는 점에서 발생한다고 생각한다.
  - null로 인해 발생하는 예외에서 자유로워진다.
  - Board의 빈 공간이라는 의미를 부여할 수 있다.
  - 출력과 기물 관리, 이동 등의 로직을 일반화할 수 있다. 예를 들어, 이전의 코드에서는 빈 공간을 출력하는 부분에서 null check 후 추가적인 상수 문자를 출력해야했다.
- Board의 행을 따로 wrap하는 것의 장점?
  - 행마다 발생하는 추가적인 기능을 구현하기에 편리해진다. Rank라는 의미를 부여할 수 있다. 명세에서 Rank 별로 처리해야하는 로직 등이 있다면 확실히 이와 같은 리팩토링이 필요할 것 같다. 
- 메서드 내의 지역 변수 이름을 어떻게 지으면 좋을까.. 일시적인 변수
- inline variable이 좋을 지, 변수를 선언해서 반환하는 게 좋을 지에 대해서 고민했다. 해당 부분이 얼마나 직관적으로 읽히는 지에 따라서 결정할 수 있을 것 같다.
- Position을 클래스로 분리하는 것의 장점
- move() 메서드명이 그 역할을 나타내지 않는 것 같다. 차후의 과제에서 수정될 것으로 보인다.
- Piece comparable 구현에 대한 고민 -> 명세에 따라 다르겠지만, Piece 객체 자체를 비교하는 기준이 score는 아닐 것이라고 판단해서, board의 메서드단에서 comparator를 구현했다.
- Rank에서 count()를 오버로딩하는 것이 바람직한가

## step 6 기록 사항
- Position 정보를 Piece에서도 유지하니까 정보가 중복된다. 같은 정보를 동시에 두 곳에 유지해야한다. 여기서 발생하는 추가적인 비용 + 오류 발생 가능성이 있다. 
- 새로운 요구사항이 발생했을 때, 이를 추가하기 위한 수정을 많이 했다. -> 확장성을 고려하면서 코드를 짜는 연습을 하면 좋을 것 같다.
- ChessGame이 Board 내 필드인 pieces와 Piece, Rank 객체에까지 의존한다. 의존 관계가 너무 복잡하다고 생각해서, Rank 내의 객체들을 더 숨기는 방식으로 리팩토링했다.
- 이동하려는 위치에 같은 편 기물이 있는지 확인하는 로직은 기능의 특성 상 Board의 일이라고 판단해서 구현하지 않았다.
- 기물 생성 팩토리 메서드를 각 자식클래스마다 만드는 것이 괜찮은가.. 중복이 늘어난다.
- 기물 객체에 VO, 팩토리 메소드를 적용하는 데는 장단점이 있는 것 같다. 이동과 다양한 이동 로직 때문에 상태가 변하는 경우가 많아서, 이 과정에서 추가적인 작업이 필요하다는 점이 단점이다.
- 일반화, 즉 인터페이스 부분을 일반적으로 만드는, 객체를 wrapping하는 작업의 중요성에 대해서 깨달았다. 과제 명세를 따라가느라 팩토리 메소드를 색/타입마다 모두 선언했다. 이 상황에서 명세가 변경되었을 때, 리팩토링해야하는 코드의 양이 매우 많았다.
Piece의 팩토리 메소드가 일반적으로 작성되어있었다면, (하나의 팩토리 메소드만이 외부에 대한 인터페이스였다면) 추상 메소드로 변경하기만 하면 되기 때문에 수정이 적었을 것이라고 생각했다. 팩토리 클래스를 따로 만드는 것. 수정에는 닫혀있고, 확장에는 열려있는 코드가 된다.
확장성에 대한 고민 

